---
title: "Refactoring 2장"
category: "Etc"
date: "2022-07-22 18:06:00 +09:00"
desc: "리팩터링 원칙"
thumbnail: "./images/refactoring/refactoring_2nd_logo.jpg"
alt: "리팩터링"
---

![image](https://user-images.githubusercontent.com/85836879/180409395-6bf40c1f-b1f6-422d-8c1f-b0387b48b886.png)

## 2장 리팩터링 원칙

---

앞 장의 예시로 리팩터링이 무엇인지 감 잡았을 것이다.

이를 토대로 이번 장에서 리팩터링 전반에 적용되는 원칙 몇 가지를 이야기하는 챕터.

## 목차

---

-   [x]  2-1. 리팩터링 정의

-   [x]  2-2. 두 개의 모자

-   [ ]  2-3. 리팩터링하는 이유

-   [ ]  2-4. 언제 리팩터링해야 할까?

-   [ ]  2-5. 리팩터링 시 고려할 문제

-   [ ]  2-6. 리팩터링, 아키텍처, 애그니(YAGNI)

-   [ ]  2-7. 리팩터링과 소프트웨어 개발 프로세스

-   [ ]  2-8. 리팩터링과 성능

-   [x]  2-9. 리팩터링의 유래

-   [ ]  2-10. 리팩터링 자동화

-   [ ]  2-11. 더 알고 싶다면

## 2-1. 리팩터링 정의
수 많은 다른 소프트웨어 개발 용어와 마찬가지로 '리팩터링'도 개발자 사이에서 두리뭉실한 의미로 통용된다.

저자는 리팩터링이라는 용어를 더 구체적으로 사용하며 엄격하게 정의해야 더 유용하다 생각한다.

명사로 사용할때의 리팩터링과 동사로 사용할때의 리팩터링 의미를 보자.

> 리팩터링[명사]: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

앞선 1장에서 본 **함수 추출하기**와 **조건부 로직을 다형성으로 바꾸기**처럼 이름이 붙어있는 리팩터링 기법들이 명사 정의에 해당된다.

> 리팩터링[동사]: 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성한다.

위에서 제시한 정의를 따르면 특정한 방식에 따라 코드를 정리하는 것만이 저자가 정의하는 리팩터링이다.

또한 리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.

> 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다.

앞에서 리팩터링 전과 후의 코드가 똑같이 동작해야 한다는 뜻에서 일부러 겉보기 동작이라는 표현을 사용했다.

하지만 완전히 똑같지는 않고 **함수 추출하기**를 거치면 콜스택이 달라져 성능이 변할 수 있고 **함수 선언 바꾸기**나 **함수 옮기기**같은 리팩터링을 하면 모듈의 인터페이스가 바뀔 때가 많다.

한편, 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 버그로 남아 있어야 한다.

(아무도 발견하지 못한 버그는 수정해도 괜찮다)

리팩터링은 성능 최적화와 비슷하지만 목적이 다를 뿐, 리퍽태링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이므로 성능은 좋아질 수도, 나빠질 수도 있다. 반면에 성능 최적화는 오로지 속도 개선에만 신경 쓴다.

그러므로 목표한 성능에 반드시 도달해야 한다면 코드는 수정하기 더 어렵게 바뀔 수도 있음을 인지해야 한다.

## 2-2. 두개의 모자
소프트웨어를 개밣할 때 목적이 '기능 추가'인지 아니면 '리팩터링'이냐를 명확히 구분해 작업한다.

켄트 벡은 이 모습을 두 개의 모자(two hats)에 비유했다.

기능을 추가할 때는 '기능 추가' 모자를 쓴 다음 기존 코드는 절대 건드리지 않고 새로운 기능을 추가하기만 한다.

'기능 추가'의 진척도는 테스트를 추가해서 통과하는지 확인하는 방식으로 측정한다.

반면에 리펙터링 할때는 '리팩터링'모자를 쓴다음 기능 추가는 절대 하지 않기로 다짐한 뒤에 올로지 코드 재구성에만 전념한다.

전체 작업 시간이 짧다 해도, 항상 내가 쓰고 있는 모자가 무엇인지와 그에 따른 미묘한 작업 방식의 차이를 분명하게 인식해야 한다.

## 2-3. 리팩터링하는 이유
리팩터링이 소프트웨어의 모든 문제점을 해결하는 만병통치약은 아니지만 코드를 건강한 상태로 유지하는 데 도와주는 약임은 분명하다.

리팩터링은 다방면으로 활용할 수 있고, 반드시 그래야 하는 도구다.

### 2-3-1. 리팩터링하면 소프트웨어 설계가 좋아진다
리팩터링을 하지않을수록 소프트웨어의 내부 설계(아키텍처)가 썩기 쉽다.

또한 코드만으로 설계를 파악하기 어려워질수록 설계를 유지하기 어렵고, 설계가 부패되는 속도는 더욱 빨라진다.

같은 일을 하는 코드가 여러 곳에 나타날 수 있기 때문이다.

중복 코드 제거는 설계 개선 작업의 중요한 한 축을 차지하며 코드량을 줄인다고 시스템이 빨라지는 것이 아니다.

프로그램의 용량이 속도에 영향을 주는 경우는 별로 없지만 코드량이 줄면 수정하는 데 드는 노력은 크게 달라진다.

코드가 길수록 실수 없이 수정하기 어려워 진다.

이해해야 할 코드량도 늘어난다.

같은 동작 혹은 비슷한 동작을 하는 코드가 산재해 있다면 한 부붑ㄴ만 살짝 바꿔서는 시스템이 예상대로 작동하지 않을 수 있다.

반면 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있으며 이는 바람직한 설계의 핵심이다.

### 2-3-2. 리팩터링하면 소프트웨어를 이해하기 쉬워진다
프로그래밍은 마치 컴퓨터와 대화하는 것과 같다.

컴퓨터에게 시킬 일을 표현하는 코드를 작성하면, 컴퓨터는 정확히 시킨 대로 반응한다.

그래서 **컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야** 한다.

프로그래밍은 내가 원하는 바를 정확히 표현하는 일이다.

문제는 프로그램을 동작시키는 데만 신경 쓰다 보면 나중에 그 코드를 다룰 개발자를 배려하지 못한다는 데 있다.

잘 작동하지만 이상적인 구조는 아닌 코드가 있다면, 시간을 내서 리팩터링을 하자.

